{% extends "RegisterGroup.hpp.in" %}
{% block methods %}
{% if group.name == 'USART' %}
    /**
     * \brief Initialize USART interface
     * \return Initialization status.
     * \retval true init was successful
     * \retval false init was not successful
     */
    template <uint32_t Baud = 9600, bool DoubleSpeed = false>
    static bool init(const CHSIZE_t CharSizeMode = CHSIZE_8BIT, const STOPBITS_t StopBitMode = ONE_BIT, const PMODE_t ParityMode = PMODE_DISABLED) {
        BOOST_STATIC_ASSERT_MSG( DoubleSpeed ? (Baud <= F_CPU / 8U) : (Baud <= F_CPU / 8U*2U), "Baud speed for UART is too high!");
        BOOST_STATIC_ASSERT_MSG( DoubleSpeed ? (Baud >= F_CPU / 4194304UL) : (Baud >= F_CPU / 4194304UL*2UL ), "Baud speed for UART is too low!");

        // init the pins
        // UART_INSTANCE::RXD_PIN::set_input();
        // UART_INSTANCE::RXD_PIN::configure(UART_INSTANCE::RXD_PIN::MODE_TOTEM);
        // UART_INSTANCE::TXD_PIN::set_output();
        // UART_INSTANCE::TXD_PIN::set_low();

        /* Find the lowest possible exponent. */
        uint32_t cpu_hz = F_CPU;
        uint32_t limit  = 0xfffU >> 4;
        uint32_t ratio  = cpu_hz / Baud;
        int8_t   exp;
        for (exp = -7; exp < 7; exp++) {
            if (ratio < limit) {
                break;
            }

            limit <<= 1;

            if (exp < -3) {
                limit |= 1;
            }
        }

        //
        // Depending on the value of exp, scale either the input frequency or the target baud rate.
        // By always scaling upwards, we never introduce any additional inaccuracy.
        //
        // We are including the final divide-by-8 (aka. right-shift-by-3) in this operation as it
        // ensures that we never exceeed 2**32 at any point.
        //
        // The formula for calculating BSEL is slightly different when exp is negative than it is when exp is positive.
        uint32_t div;
        if (exp < 0) {
            // We are supposed to subtract 1, then apply BSCALE. We want to apply BSCALE first,
            // so we need to turn everything inside the parenthesis into a single fractional expression.
            cpu_hz -= 8 * Baud;

            // If we end up with a left-shift after taking the final divide-by-8 into account, do the shift before the divide.
            // Otherwise, left-shift the denominator instead (effectively resulting in an overall right shift.)
            if (exp <= -3) {
                div = ((cpu_hz << (-exp - 3)) + Baud / 2) / Baud;
            } else {
                const uint32_t baudShift = Baud << exp + 3;
                div = (cpu_hz + baudShift / 2) / baudShift;
            }
        } else {
            // We will always do a right shift in this case,
            // but we need to shift three extra positions because of the divide-by-8.
            const uint32_t baudShift = Baud << exp + 3;
            div = (cpu_hz + baudShift / 2) / baudShift - 1;
        }

        BAUDCTRLB::write( ((div >> 8) & 0X0F) | (exp << 4) );
        BAUDCTRLA::write( div );

        CTRLC::write( ParityMode << CTRLC::PMODE::SHIFT             // Parity
                      | StopBitMode << CTRLC::SBMODE::SHIFT         // Stop Bit Mode
                      | CharSizeMode                                // Character size, in position 0 so no shift
                      | CMODE_ASYNCHRONOUS << CTRLC::CMODE::SHIFT); // Async Polled Mode

        CTRLB::write( DoubleSpeed << CTRLB::CLK2X::SHIFT            // Double transmission speed
                     | 0 << CTRLB::MPCM::SHIFT                      // Multi-processor Communication Mode: disabled
                     | 1 << CTRLB::RXEN::SHIFT                      // Receiver Enable: enabled
                     | 1 << CTRLB::TXEN::SHIFT);                    // Transmitter Enable: enabled

        return true;
    }

    /// Enables the USART module by setting the RX and TX enable-bits in the USART control register
    static void enable_tx() {
        CTRLB::TXEN::write(1);
    }

    /// Enables the USART module by setting the RX enable-bit in the USART control register
    static void enable_rx() {
        CTRLB::RXEN::write(1);
    }

    /// Enables the USART module by setting the TX enable-bit in the USART control register
    static void enable() {
        CTRLB::write( CTRLB::READ() | CTRLB::TXEN::BIT_MASK | CTRLB::RXEN::BIT_MASK );
    }

    /// Disables the USART module by clearing the enable-bit(s) in the USART control register
    static void disable() {
        CTRLB::write( CTRLB::READ() & ~(CTRLB::TXEN::BIT_MASK | CTRLB::RXEN::BIT_MASK) );
    }

    /**
     * \brief Get recieved data from USART_0
     * \return Data register from USART_0 module
     */
    static uint8_t get_data() {
        return DATA::read();
    }

    /**
     * \brief Check if the usart can accept data to be transmitted
     * \return The status of USART TX data ready check
     * \retval false The USART can not receive data to be transmitted
     * \retval true The USART can receive data to be transmitted
     */
    static bool tx_ready() {
        return STATUS::DREIF::read();
    }

    /**
     * \brief Check if the USART has received data
     * \return The status of USART RX data ready check
     * \retval true The USART has received data
     * \retval false The USART has not received data
     */
    static bool rx_ready() {
        return STATUS::RXCIF::read();
    }

    /**
     * \brief Check if USART_0 data is transmitted
     * \return Receiver ready status
     * \retval true  Data is not completely shifted out of the shift register
     * \retval false Data completely shifted out if the USART shift register
     */
    static bool tx_busy() {
        return !STATUS::TXCIF::read();
    }

    /**
     * \brief Read one character from USART_0
     * Function will block if a character is not available.
     * \return Data read from the USART_0 module
     */
    static uint8_t read() {
        while (!STATUS::RXCIF::read()) {}
        return DATA::read();
    }

    /**
     * \brief Write one character to USART_0
     * Function will block until a character can be accepted.
     * \param[in] data The character to write to the USART
     * \return Nothing
     */
    static void write(const uint8_t data) {
        while (!STATUS::DREIF::read()) {}
        DATA::write(data);
    }
{% endif %}
{% endblock %}
